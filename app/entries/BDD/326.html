<div><a href="http://www.chicoree.fr/w/Renommer_une_base_MySQL">http://www.chicoree.fr/w/Renommer_une_base_MySQL</a></div><div><br></div><div>Il vous est sans doute déjà arrivé de devoir renommer une base de données. Par exemple, parce que vous constatez après l'avoir créée que vous vous êtes trompé dans son nom. Ou parce qu'au cours du développement votre base a évolué et que son nom ne reflète plus la réalité de votre projet. Ou pour plein d'autres raisons qui vous sont personnelles…</div><div><br></div><div>Malheureusement, MySQL ne supporte pas la commande ALTER DATABASE ... RENAME TO ... Mais il existe d'autres solutions.&nbsp;</div><div><br></div><div><div><font size="4">Utiliser une sauvegarde</font></div><div><br></div><div>Cette technique a pour avantage de fonctionner quel que soit le type de vos tables (y compris InnoDB) et d'être utilisable en toute sécurité sur une base de donnée live. Si vous faites ce dernier choix cependant, il faut avoir conscience que les modifications effectuées après le début de la procédure ne seront sans doute pas présentes dans la base copiée. Mais au moins cela vous permet de conserver la base accessible en lecture pendant la transition.</div><div><br></div><div>Le truc ici va simplement consister à faire une sauvegarde (un backup) de la base existante à l'aide de l'utilitaire <b>mysqldump </b>qui devrait être disponible dans toute distribution de MySQL. Puis de ré-importer ce backup dans une autre base.&nbsp;</div><div><br></div><div><i>Note </i>: Accessoirement, cette technique vous permettra aussi de migrer une base d'un serveur à un autre, mais ce n'est pas l'objet de cet article.</div></div><div><br></div><div><blockquote><font face="menlo"># Faire un backup de la base -- utilisez vos options habituelles ici<br>sh$ mysqldump --quick --single-transaction --routines --triggers --user=root --password MyDatabase &gt; backup.sql</font></blockquote><div><br></div><blockquote><font face="menlo"># Creér une nouvelle base de données et y importer la sauvegarde<br>sh$ mysql --user=root --password<br>Enter password:<br>Welcome to the MySQL monitor. Commands end with ; or \g.<br><br>mysql&gt; CREATE DATABASE MyNewDatabase;<br>Query OK, 1 row affected (0.06 sec)<br><br>mysql&gt; use MyNewDatabase<br>Database changed<br><br>mysql&gt; source ./backup.sql</font></blockquote><div><font face="menlo"><br></font></div><div><font face="menlo">U</font>ne fois l'exécution du script SQL terminée, vous allez vous retrouvez avec deux exemplaires de la même base de données.</div><div><br></div><blockquote><font face="menlo">mysql&gt; SHOW DATABASES;<br>+--------------------+<br>| Database |<br>+--------------------+<br>| information_schema |<br>| MyDatabase |<br>| MyNewDatabase |<br>| mysql |<br>+--------------------+<br>4 rows in set (0.00 sec)</font></blockquote><div><br></div><div>Mais avant de pouvoir effectuer la transition de l'une à l'autre dans vos applications clientes, il vous faudra récupérer les permissions de l'ancienne base pour les affecter à la nouvelle.</div><div><br></div><div><i><b>Remarque:</b></i></div><div><br></div><div>À partir de maintenant, vous pouvez à n'importe quel moment supprimer votre ancienne base de données avec DROP DATABASE puisque dans MySQL cette commande ne fait pas disparaitre les permissions relatives à la base de données supprimée.</div></div><div><br></div><div><div><font size="4">Ajuster les permissions</font></div><div><br></div><div>Que vous ayez renommé votre base en passant par un blackup, en déplaçant les tables ou en modifiant sauvagement le nom de dossiers, il vous reste une étape avant de terminer: ajuster les permissions de la nouvelle base. Là, deux écoles. Avec toutes deux leurs défauts:</div><div><br></div><div><ul><li>recréer toutes les permissions à la main</li></ul></div><div>C'est fastidieux – et source d'erreur. En plus, après avoir recréé les permissions il faudra aussi penser à supprimer celles sur l'ancienne base.</div><div><ul><li>migrer les permissions</li></ul></div><div>Avec cette solution on met à jour la table des permissions en changeant l'ancien nom de la base par le nouveau. Avec pour inconvénient qu'il faut toujours réfléchir à deux fois avant d'aller modifier les tables administratives de MySQL – et que cette technique est susceptible de devenir obsolète le jour ou MySQL AB décidera de changer la manière de gérer les permissions…</div><div><br></div><div>Avec toutes les réserves évoquées, c'est tout de même la seconde option que je vais détailler. En effet, le première n'étant qu'une succession de GRANT et REVOKE, elle ne présente que peu d'intérêt à étudier.</div><div><br></div><div>Bref, pour gérer les permissions, MySQL utilise des données stockées dans un certain nombre de tables: mysql.db, mysql.host, mysql.tables_priv, mysql.columns_priv, mysql.procs_priv. Il va donc falloir modifier dans chacune de ces tables le nom de la base de données pour refléter les modifications effectuées:</div><div><br></div><blockquote><font face="menlo">mysql&gt; UPDATE mysql.db SET Db='MyNewDatabase' WHERE Db='MyDatabase';<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1 Changed: 1 Warnings: 0</font></blockquote><div><br></div><blockquote><font face="menlo">mysql&gt; UPDATE mysql.host SET Db='MyNewDatabase' WHERE Db='MyDatabase';<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 0 Changed: 0 Warnings: 0</font></blockquote><div><br></div><blockquote><font face="menlo">mysql&gt; UPDATE mysql.tables_priv SET Db='MyNewDatabase' WHERE Db='MyDatabase';<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 0 Changed: 0 Warnings: 0</font></blockquote><div><br></div><blockquote><font face="menlo">mysql&gt; UPDATE mysql.columns_priv SET Db='MyNewDatabase' WHERE Db='MyDatabase';<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 0 Changed: 0 Warnings: 0</font></blockquote><div><br></div><blockquote><font face="menlo">mysql&gt; UPDATE mysql.procs_priv SET Db='MyNewDatabase' WHERE Db='MyDatabase';<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 0 Changed: 0 Warnings: 0</font></blockquote></div>